
-- 1. STORAGE: BUCKET OLUŞTURMA
-- Storage schema'sına bucket ekliyoruz. public=true yaparak herkese açık yapıyoruz.
INSERT INTO storage.buckets (id, name, public) 
VALUES ('urun-dokumanlari', 'urun-dokumanlari', true) 
ON CONFLICT (id) DO UPDATE SET public = true;

-- Bucket erişim politikaları (Basitçe herkese açık yapıyoruz demo için)
-- Not: Storage politikalarını SQL ile yönetmek karmaşık olabilir, genellikle RLS ile yapılır.
-- Ancak bucket public=true olduğu için okuma sorunu olmayacaktır. Yazma için service_role veya policy gerekir.

-- 2. SCHEMA: PROFILES TABLOSU VE IDENTITY FIX
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid REFERENCES auth.users ON DELETE CASCADE,
  updated_at timestamp with time zone,
  username text UNIQUE,
  full_name text,
  avatar_url text,
  website text,
  CONSTRAINT profiles_pkey PRIMARY KEY (id),
  CONSTRAINT profiles_username_check CHECK (char_length(username) >= 3)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Identity Fixes (Mevcut verileri koruyarak identity ekle)
DO $$
DECLARE
    t text;
    pk text;
    has_identity boolean;
BEGIN
    FOR t, pk IN VALUES 
        ('uretim_kayit', 'uretim_id'),
        ('siparis', 'siparis_id'),
        ('siparis_maliyet', 'siparis_maliyet_id'),
        ('hammadde', 'hammadde_id'),
        ('makine', 'makine_id'),
        ('makine_ariza', 'ariza_id'),
        ('makine_bakim', 'bakim_id'),
        ('musteriler', 'musteri_id'),
        ('personel', 'personel_id'),
        ('tedarikciler', 'tedarikci_id'),
        ('urun_stok', 'urun_stok_id'),
        ('urun', 'urun_id')
    LOOP
        -- Check if column is already identity
        SELECT is_identity INTO has_identity 
        FROM information_schema.columns 
        WHERE table_schema = 'public' AND table_name = t AND column_name = pk;

        IF NOT has_identity THEN
            -- Fix for "already has a default value" error: Drop existing default (e.g. serial sequence)
            EXECUTE format('ALTER TABLE public.%I ALTER COLUMN %I DROP DEFAULT', t, pk);
            EXECUTE format('ALTER TABLE public.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY', t, pk);
        END IF;

        -- Update sequence
        EXECUTE format('SELECT setval(pg_get_serial_sequence(''%I'', ''%I''), COALESCE((SELECT MAX(%I) FROM public.%I), 0) + 1, false)', t, pk, pk, t);
    END LOOP;
END $$;

-- uretim_kayit makine_id identity fix
ALTER TABLE public.uretim_kayit ALTER COLUMN makine_id DROP IDENTITY IF EXISTS;

-- 3. DATA SEEDING (Önce temizle, sonra ekle)
-- Foreign Key constraintleri nedeniyle sıralama önemlidir.
-- Cascade truncate ile temizliyoruz.
TRUNCATE TABLE 
  public.siparis_maliyet, 
  public.siparis, 
  public.uretim_kayit, 
  public.urun_recetesi, 
  public.urun_stok, 
  public.hammadde_hareket, 
  public.makine_ariza, 
  public.makine_bakim, 
  public.hammadde, 
  public.makine, 
  public.urun, 
  public.musteriler, 
  public.tedarikciler, 
  public.personel 
RESTART IDENTITY CASCADE;

-- Insert Data (Buraya seed_data.sql içeriğinin tamamını kopyalıyoruz - tool kopyalayacak)
-- NOT: Kopyalama işlemini run_full_setup.js içinde concat yaparak halledeceğim, buraya sadece placeholder koymuyorum.
-- Bu dosya sadece şema ve bucket fixleri için temel olsun.
-- Data kısmını run_full_setup.js dosyasında seed_data.sql'den okuyup ekleyeceğim.
